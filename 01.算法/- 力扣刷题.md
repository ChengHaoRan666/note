## 1. [两数之和](https://leetcode.cn/problems/two-sum/)

基础做法：两层for便利，找到数组中和为规定值的下标，返回

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        for (int i = 0; i < nums.length; i++) {
            for (int j = 0; j < nums.length && i != j; j++) {
                if (nums[i] + nums[j] == target) {
                    return new int[]{i, j};
                }
            }
        }
        return null;
    }
}
```

优化一：使用map记录内容和下标，判断有没有下标来进行返回

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        // 记录位置和下标
        for (int i = 0; i < nums.length; i++) {
            map.put(nums[i], i);
        }
        // 计算target-大小是否有值
        for (int i = 0; i < nums.length; i++) {
            if (map.get(target - nums[i]) != null && map.get(target - nums[i]) != i) {
                return new int[]{i, map.get(target - nums[i])};
            }
        }
        return null;
    }
}
```

进一步优化：一次遍历得到map，进行判断

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for(int i = 0; i < nums.length; i++){
            if(map.containsKey(target - nums[i])){
                return new int[]{map.get(target-nums[i]),i};
            }         
            map.put(nums[i],i);
        }
        return null;
    }
}
```



## 2. [字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

使用map，记录每一个排序后的字符串和排序前的字符串列表

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        // key: 排序后的  val: 原本str的list集合
        Map<String, List<String>> map = new HashMap<>();
        for (String str : strs) {
            char[] chs = str.toCharArray();
            Arrays.sort(chs);
            String str2 = new String(chs);
            // 如果有，说明有字母异位词
            List<String> list;
            if (map.containsKey(str2)) {
                list = map.get(str2);
            } else {
                list = new ArrayList<>();
            }
            list.add(str);
            map.put(str2, list);
        }
        return new ArrayList<>(map.values());
    }
}
```



## 3. [最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        Set<Integer> st = new HashSet<>();
        for (int num : nums) {
            st.add(num); // 把 nums 转成哈希集合
        }

        int ans = 0;
        for (int x : st) { // 遍历哈希集合
            if (st.contains(x - 1)) { // 如果 x 不是序列的起点，直接跳过
                continue;
            }
            // x 是序列的起点
            int y = x + 1;
            while (st.contains(y)) { // 不断查找下一个数是否在哈希集合中
                y++;
            }
            // 循环结束后，y-1 是最后一个在哈希集合中的数
            ans = Math.max(ans, y - x); // 从 x 到 y-1 一共 y-x 个数
        }
        return ans;
    }
}
```



## 4. [移动零](https://leetcode.cn/problems/move-zeroes/)

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int left = 0; // 指向当前需要被替换的零的位置
        int right = 0; // 遍历指针，寻找非零元素

        while (right < nums.length) {
            if (nums[right] != 0) {
                // 交换 left 和 right 位置的元素
                int temp = nums[left];
                nums[left] = nums[right];
                nums[right] = temp;
                left++;
            }
            right++;
        }
    }
}
```
## 一. 导入项目模块，连通测试

1. 将项目导入idea，或者自己创建再将东西放进去也行
2. 添加git管理
   2.1 idea开启版本控制
   2.2 设置不添加版本控制的文件和文件夹
   2.3 项目右键git选择管理远程
   2.4 github上创建仓库，得到SSH链接，在idea中为项目添加远程仓库
   2.5 测试提交
3. 搭建前端环境
4. 搭建数据库环境
5. 前后端联调



<font color="red">使用nginx实现反向代理和负载均衡</font>



## 二. 导入接口文档和生成测试接口文档

使用`yapi`导入接口文档



### 2.1 Swagger 介绍

Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务(<https://swagger.io/>)。 它的主要作用是：

1. 使得前后端分离开发更加方便，有利于团队协作

2. 接口的文档在线自动生成，降低后端开发人员编写接口文档的负担

3. 功能测试 

   Spring已经将Swagger纳入自身的标准，建立了Spring-swagger项目，现在叫Springfox。通过在项目中引入Springfox ，即可非常简单快捷的使用Swagger。

knife4j是为Java MVC框架集成Swagger生成Api文档的增强解决方案,前身是swagger-bootstrap-ui,取名kni4j是希望它能像一把匕首一样小巧,轻量,并且功能强悍!

目前，一般都使用knife4j框架。



### 2.2 使用步骤

1. 导入 knife4j 的maven坐标

   在pom.xml中添加依赖

   ```xml
   <dependency>
      <groupId>com.github.xiaoymin</groupId>
      <artifactId>knife4j-spring-boot-starter</artifactId>
   </dependency>
   ```

2. 在配置类中加入 knife4j 相关配置

   WebMvcConfiguration.java

   ```java
   /**
        * 通过knife4j生成接口文档
        * @return
   */
       @Bean
       public Docket docket() {
           ApiInfo apiInfo = new ApiInfoBuilder()
                   .title("苍穹外卖项目接口文档")
                   .version("2.0")
                   .description("苍穹外卖项目接口文档")
                   .build();
           Docket docket = new Docket(DocumentationType.SWAGGER_2)
                   .apiInfo(apiInfo)
                   .select()
                   .apis(RequestHandlerSelectors.basePackage("com.sky.controller"))
                   .paths(PathSelectors.any())
                   .build();
           return docket;
       }
   ```

   

3. 设置静态资源映射，否则接口文档页面无法访问

   WebMvcConfiguration.java

   ```java
   /**
        * 设置静态资源映射
        * @param registry
   */
   protected void addResourceHandlers(ResourceHandlerRegistry registry) {
           registry.addResourceHandler("/doc.html").addResourceLocations("classpath:/META-INF/resources/");
           registry.addResourceHandler("/webjars/**").addResourceLocations("classpath:/META-INF/resources/webjars/");
   }
   ```

4. 访问测试

   接口文档访问路径为 http://ip:port/doc.html ---> http://localhost:8080/doc.html



### 2.3 常用注解

通过注解可以控制生成的接口文档，使接口文档拥有更好的可读性，常用注解如下：

| **注解**          | **说明**                                               |
| ----------------- | ------------------------------------------------------ |
| @Api              | 用在类上，例如Controller，表示对类的说明               |
| @ApiModel         | 用在类上，例如entity、DTO、VO                          |
| @ApiModelProperty | 用在属性上，描述属性信息                               |
| @ApiOperation     | 用在方法上，例如Controller的方法，说明方法的用途、作用 |

接下来，使用上述注解，生成可读性更好的接口文档

在sky-pojo模块中

EmployeeLoginDTO.java

```java
package com.sky.dto;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

import java.io.Serializable;

@Data
@ApiModel(description = "员工登录时传递的数据模型")
public class EmployeeLoginDTO implements Serializable {

    @ApiModelProperty("用户名")
    private String username;

    @ApiModelProperty("密码")
    private String password;

}

```

EmployeeLoginVo.java

```java
package com.sky.vo;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@ApiModel(description = "员工登录返回的数据格式")
public class EmployeeLoginVO implements Serializable {

    @ApiModelProperty("主键值")
    private Long id;

    @ApiModelProperty("用户名")
    private String userName;

    @ApiModelProperty("姓名")
    private String name;

    @ApiModelProperty("jwt令牌")
    private String token;

}
```

在sky-server模块中

EmployeeController.java

```java
package com.sky.controller.admin;

import com.sky.constant.JwtClaimsConstant;
import com.sky.dto.EmployeeLoginDTO;
import com.sky.entity.Employee;
import com.sky.properties.JwtProperties;
import com.sky.result.Result;
import com.sky.service.EmployeeService;
import com.sky.utils.JwtUtil;
import com.sky.vo.EmployeeLoginVO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.HashMap;
import java.util.Map;

/**
 * 员工管理
 */
@RestController
@RequestMapping("/admin/employee")
@Slf4j
@Api(tags = "员工相关接口")
public class EmployeeController {

    @Autowired
    private EmployeeService employeeService;
    @Autowired
    private JwtProperties jwtProperties;

    /**
     * 登录
     *
     * @param employeeLoginDTO
     * @return
     */
    @PostMapping("/login")
    @ApiOperation(value = "员工登录")
    public Result<EmployeeLoginVO> login(@RequestBody EmployeeLoginDTO employeeLoginDTO) 	{
        //..............

        
    }

    /**
     * 退出
     *
     * @return
     */
    @PostMapping("/logout")
    @ApiOperation("员工退出")
    public Result<String> logout() {
        return Result.success();
    }

}

```

启动服务：访问http://localhost:8080/doc.html





## 三. 员工操作

### 1. 实现添加员工

拷贝属性可以使用`  BeanUtils.copyProperties(employeeDTO, employee);`方法，第一个参数是源数据，第二个参数是要拷贝进去的数据。

```java
  BeanUtils.copyProperties(employeeDTO, employee);
```

```java
employee.setName(employeeDTO.getName());
employee.setUsername(employeeDTO.getUsername());
employee.setPhone(employeeDTO.getPhone());
employee.setSex(employeeDTO.getSex());
employee.setIdNumber(employeeDTO.getIdNumber());
```





密码使用`md5`加密

```java
DigestUtils.md5DigestAsHex("123456".getBytes())
```

使用这个工具类实现





```java
LocalDateTime.now()
```

可以获取当前时间





> 优化一：
>
> 问题：添加已存在用户时无反馈
>
> 解决方式：添加一个异常处理器，将sql中插入时重复的异常进行处理

> 优化二：
>
> 问题：在创建用户时需要动态获取创建人的id
>
> 解决方式：使用`THreadLocal`来将数据存储到对应线程内，实现线程内通信。
>    						1. 在执行到JWT令牌校验时获取到当前线程，将当前操作人的 id 存入
>       						2. 在插入新员工时，从线程中获取之前存入的操作人的 id 





### 2. 员工分页查询

在这个功能中参数不是通过json传送到后端，而是通过`Form`的方式传给后端（就是?key=val&.)这时候spring会自动匹配属性，如果有一个类中的属性和传入的参数名称相同，就会将传入参数的值写入这个类中。如果是通过`json`方式传入，需要使用`@RequestBody`来进行获取参数

```java
 	@GetMapping("/page")
    @ApiOperation("员工分页查询")
    public Result<PageResult> getEmp(EmployeePageQueryDTO employeePageQueryDTO) {
        PageResult pageResult = employeeService.pageQuery(employeePageQueryDTO);
        return Result.success(pageResult);
    }
```





分页操作可以使用分页插件实现

```xml
<!--分页插件-->
<dependency>
    <groupId>com.github.pagehelper</groupId>
    <artifactId>pagehelper-spring-boot-starter</artifactId>
    <version>${pagehelper}</version>
</dependency>
<!--/分页插件-->
```

只需要进行开启，传入参数：查询页码，每页条数 即可

原理也是使用`THreadLocal`线程将数据保存，之后在执行sql语句时读取再进行拼接

```java
PageHelper.startPage(employeePageQueryDTO.getPage(), employeePageQueryDTO.getPageSize());
```





### 3. 修改密码

传入的参数只有旧密码和新密码，输入的两次密码是否匹配是在前端进行判断的，用户id是从JWT拦截器中获取的存入线程中的。注意密码是经过md5加密的，要注意加密密码和源密码的转换



### 4. 修改员工信息

通过编写修改Mapper中的修改来实现，判断是否为null，不为null就用新的值进行覆盖，为null就还是原来的值







## 四. 分类操作

## 五. 公共字段填充

在代码中有几个属性每次修改都需要重新赋值，而且赋的值都是一样的，可以采用以下方法解决：

1. 自定义注解`AotoFill`，用于表示需要进行公共字段自动填充的方法
2. 自定义切面类`AutoFillAspect`，统一拦截加入了`AutoFill`注解的方法，通过反射未公共字段赋值
3. 在`Mapper`的方法上加入`AutoFill`注解





1. 先创建一个注解，用于表示需要进行Aop操作的方法

   ```java
   package com.sky.annotaion;
   
   import com.sky.enumeration.OperationType;
   
   import java.lang.annotation.ElementType;
   import java.lang.annotation.Retention;
   import java.lang.annotation.RetentionPolicy;
   import java.lang.annotation.Target;
   
   /**
    * @Author: 程浩然
    * @Create: 2024/11/16 - 16:27
    * @Description: 自定义注解，用于表示某个方法需要进行功能字段自动填充处理
    */
   // 表示可以加在方法上
   @Target(ElementType.METHOD)
   // 标记注解在运行时保留
   @Retention(RetentionPolicy.RUNTIME)
   public @interface AutoFill {
       // 数据库操作类型 UPDATE INSERT
       OperationType value();
   }
   ```

2. 创建一个切面，用于处理操作

   ```java
   package com.sky.aspect;
   
   import com.sky.annotaion.AutoFill;
   import com.sky.constant.AutoFillConstant;
   import com.sky.context.BaseContext;
   import com.sky.enumeration.OperationType;
   import lombok.extern.slf4j.Slf4j;
   import org.aspectj.lang.JoinPoint;
   import org.aspectj.lang.annotation.Aspect;
   import org.aspectj.lang.annotation.Before;
   import org.aspectj.lang.annotation.Pointcut;
   import org.aspectj.lang.reflect.MethodSignature;
   import org.springframework.stereotype.Component;
   
   import java.lang.reflect.InvocationTargetException;
   import java.lang.reflect.Method;
   import java.time.LocalDateTime;
   
   /**
    * @Author: 程浩然
    * @Create: 2024/11/16 - 16:32
    * @Description: 自定义切面，实现公共字段自动填充逻辑
    */
   @Aspect
   @Slf4j
   @Component
   public class AutoFillAspect {
       /**
        * 切入点<br>
        * execution(* com.sky.mapper.*.*(..))：找到对应类的全部方法都进行切面<br>
        * @annotation(com.sky.annotaion.AutoFill) 找到加上了AutoFill注解的方法进行切面
        */
       @Pointcut("execution(* com.sky.mapper.*.*(..)) && @annotation(com.sky.annotaion.AutoFill)")
       public void autoFillPointCut() {}
   
       @Before("autoFillPointCut()")
       public void autoFill(JoinPoint joinPoint) {
           log.info("开始进行公共字段自动填充...");
           // 1. 获取被拦截的方法上的数据库操作的类型
           MethodSignature signature = (MethodSignature) joinPoint.getSignature(); // 方法签名对象
           AutoFill autoFill = signature.getMethod().getAnnotation(AutoFill.class); // 获取方法上的注解对象
           OperationType operationType = autoFill.value(); // 获取数据库操作类型
   
           // 2. 获取当前被拦截方法的参数--实体对象
           Object[] args = joinPoint.getArgs();
           if (args == null || args.length == 0) {
               return;
           }
           Object entity = args[0];
   
           // 3. 为实体对象的公共属性进行赋值
           LocalDateTime time = LocalDateTime.now();
           Long currentId = BaseContext.getCurrentId();
           // 3.1 如果操作是插入操作，需要对四个值都赋值
           if (operationType == OperationType.INSERT) {
               try {
                   // 3.1.1 获取方法
                   Method setCreateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_TIME, LocalDateTime.class);
                   Method setCreateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_USER, Long.class);
                   Method setUpdateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);
                   Method setUpdateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);
   
                   // 3.1.2 通过反射为对象赋值
                   setCreateTime.invoke(entity, time);
                   setCreateUser.invoke(entity, currentId);
                   setUpdateTime.invoke(entity, time);
                   setUpdateUser.invoke(entity, currentId);
               } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
                   e.printStackTrace();
               }
           }
           // 3.2 如果操作是修改操作，需要对两个值进行赋值
           else if (operationType == OperationType.UPDATE) {
               try {
                   // 3.2.1 获取方法
                   Method setUpdateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);
                   Method setUpdateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);
   
                   // 3.2.2 通过反射为对象赋值
                   setUpdateTime.invoke(entity, time);
                   setUpdateUser.invoke(entity, currentId);
               } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
                   e.printStackTrace();
               }
           }
       }
   }
   ```

4. 在有公共字段（创建日期，更新日期，创建人，更新人）填充的方法上使用注解表示（注意这个类要在切入点规定的包内），删除里面的更新公共字段的语句





## 六. 文件上传到阿里云OSS

1. 写配置信息

   ```yaml
     # 阿里OSS配置
     sky:
         alioss:
           endpoint: oss-cn-beijing.aliyuncs.com
           access-key-id: x
           access-key-secret: 1X0ajS5ZqlZhJLGbEr8TFIKAIfPsfx
           bucket-name: sky-image-2
   ```

2. 写配置信息对应的实体类，以便可以读取到配置信息

   ```java
   @Component
   @ConfigurationProperties(prefix = "sky.alioss")
   @Data
   public class AliOssProperties {
   
       private String endpoint;
       private String accessKeyId;
       private String accessKeySecret;
       private String bucketName;
   }
   ```

3. 编写OSS的配置类，获取已经加入到Spring管理的配置信息实体类的信息，通过这些信息创建阿里云OSS工具类（在创建前要先判断是否存在，存在就不创建`ConditionalOnMissingBean`），并加入Spring管理，以便后面自动注入得到`AliOssUtil`。

   ```java
   @Configuration
   @Slf4j
   public class OssConfiguration {
       @Bean
       @ConditionalOnMissingBean
       public AliOssUtil aliOssUtil(AliOssProperties aliOssProperties) {
           return new AliOssUtil(aliOssProperties.getEndpoint(), aliOssProperties.getAccessKeyId(), aliOssProperties.getAccessKeySecret(), aliOssProperties.getBucketName());
       }
   }
   ```

4. 写`AllOssUtil`工具类，通过配置信息创建，里面有上传文件的方法

   ```java
   package com.sky.utils;
   
   import com.aliyun.oss.ClientException;
   import com.aliyun.oss.OSS;
   import com.aliyun.oss.OSSClientBuilder;
   import com.aliyun.oss.OSSException;
   import lombok.AllArgsConstructor;
   import lombok.Data;
   import lombok.extern.slf4j.Slf4j;
   
   import java.io.ByteArrayInputStream;
   
   @Data
   @AllArgsConstructor
   @Slf4j
   public class AliOssUtil {
   
       private String endpoint;
       private String accessKeyId;
       private String accessKeySecret;
       private String bucketName;
   
       /**
        * 文件上传
        *
        * @param bytes
        * @param objectName
        * @return
        */
       public String upload(byte[] bytes, String objectName) {
   
           // 创建OSSClient实例。
           OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);
   
           try {
               // 创建PutObject请求。
               ossClient.putObject(bucketName, objectName, new ByteArrayInputStream(bytes));
           } catch (OSSException oe) {
               System.out.println("Caught an OSSException, which means your request made it to OSS, "
                       + "but was rejected with an error response for some reason.");
               System.out.println("Error Message:" + oe.getErrorMessage());
               System.out.println("Error Code:" + oe.getErrorCode());
               System.out.println("Request ID:" + oe.getRequestId());
               System.out.println("Host ID:" + oe.getHostId());
           } catch (ClientException ce) {
               System.out.println("Caught an ClientException, which means the client encountered "
                       + "a serious internal problem while trying to communicate with OSS, "
                       + "such as not being able to access the network.");
               System.out.println("Error Message:" + ce.getMessage());
           } finally {
               if (ossClient != null) {
                   ossClient.shutdown();
               }
           }
   
           //文件访问路径规则 https://BucketName.Endpoint/ObjectName
           StringBuilder stringBuilder = new StringBuilder("https://");
           stringBuilder
                   .append(bucketName)
                   .append(".")
                   .append(endpoint)
                   .append("/")
                   .append(objectName);
   
           log.info("文件上传到:{}", stringBuilder);
   
           return stringBuilder.toString();
       }
   }
   ```

5. 实现上传文件接口

   ```java
   package com.sky.controller.admin;
   
   import com.sky.constant.MessageConstant;
   import com.sky.result.Result;
   import com.sky.utils.AliOssUtil;
   import io.swagger.annotations.Api;
   import io.swagger.annotations.ApiOperation;
   import lombok.extern.slf4j.Slf4j;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.web.bind.annotation.PostMapping;
   import org.springframework.web.bind.annotation.RequestMapping;
   import org.springframework.web.bind.annotation.RequestPart;
   import org.springframework.web.bind.annotation.RestController;
   import org.springframework.web.multipart.MultipartFile;
   
   import java.io.IOException;
   import java.util.UUID;
   
   /**
    * @Author: 程浩然
    * @Create: 2024/11/16 - 20:24
    * @Description: 通用接口
    */
   @Api(tags = "通用接口")
   @RestController
   @RequestMapping("/admin/common")
   @Slf4j
   public class CommonController {
   
       @Autowired
       private AliOssUtil aliOssUtil;
   
       @ApiOperation("文件上传")
       @PostMapping("/upload")
       public Result<String> upload(@RequestPart("file") MultipartFile file) {
           try {
               //原始文件名
               String originalFilename = file.getOriginalFilename();
               //截取原始文件名的后缀
               String extension = originalFilename.substring(originalFilename.lastIndexOf("."));
               //构造新文件名称
               String objectName = UUID.randomUUID() + extension;
   
               //文件的请求路径
               String filePath = aliOssUtil.upload(file.getBytes(), objectName);
               return Result.success(filePath);
           } catch (IOException e) {
               log.error("文件上传失败：{}", e);
           }
   
           return Result.success(MessageConstant.UPLOAD_FAILED);
       }
   }
   ```

   

## 七. 菜品添加，根据id查询菜品




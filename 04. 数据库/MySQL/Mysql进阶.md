## 存储引擎

### 1. Mysql体系结构



![Mysql体系结构](https://ChengHaoRan666.github.io/picx-images-hosting/MySQL/Mysql体系结构.2h8nl1bnug.webp)

> 自上而下：连接层，服务层，引擎层，存储层

#### 1. 连接层

最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于 TCP/IP的通信。主要完成一些类似于==连接处理==、==授权认证==、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。



#### 2. 服务层

第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等， 最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大， 这样在解决大量读操作的环境中能够很好的提升系统的性能。



#### 3. 引擎层

存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。数据库中的索引是在存储引擎层实现的。



#### 4. 存储层

数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询 日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。



### 2. 存储引擎介绍

1. 存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式
2. 存储引擎是基于表的，而不是 基于库的，所以存储引擎也可被称为表类型
3. 我们可以在创建表的时候指定存储引擎，如果没有指定，使用默认的 InnoDB 存储引擎

> 在建表语句加上`ENGINE =InnoDB`可以指定存储引擎

> 使用`show engines`可以查看支持的存储引擎

| 存储引擎                        | 是否支持 | 注解                                         | 事务 | 分布式事务 | 保存点 |
| ------------------------------- | -------- | -------------------------------------------- | ---- | ---------- | ------ |
| <font color="red">MEMORY</font> | YES      | 基于哈希，存储在内存中，适用于临时表         | NO   | NO         | NO     |
| MRG_MYISAM                      | YES      | 相同的 MyISAM 表集合                         | NO   | NO         | NO     |
| CSV                             | YES      | CSV 存储引擎                                 | NO   | NO         | NO     |
| FEDERATED                       | NO       | 联合 MySQL 存储引擎                          |      |            |        |
| PERFORMANCE_SCHEMA              | YES      | 性能模式                                     | NO   | NO         | NO     |
| <font color="red">MyISAM</font> | YES      | MyISAM 存储引擎                              | NO   | NO         | NO     |
| <font color="red">InnoDB</font> | DEFAULT  | 支持事务、行级锁定和外键                     | YES  | YES        | YES    |
| ndbinfo                         | NO       | MySQL Cluster 系统信息存储引擎               |      |            |        |
| BLACKHOLE                       | YES      | /dev/null 存储引擎（写入的任何内容都会消失） | NO   | NO         | NO     |
| ARCHIVE                         | YES      | 归档存储引擎                                 | NO   | NO         | NO     |
| ndbcluster                      | NO       | 集群容错表                                   |      |            |        |



### 3. 存储引擎特点

#### 1. InnoDB

InnoDB是一种兼顾高可用性和高性能的通用存储引擎，在MySQL 5.5 之后作为默认存储引擎。



##### 特点：

1. 支持事务：DML操作（增删改）遵循ACID模型，支持事务
2. 行级锁：支持行级锁，提高并发访问性能
3. 外键：支持外键 FOREIGN KEY 约束，保证数据完整性和正确性



##### 文件存储：

InnoDB存储引擎会将每张表的表结构，数据，索引存放在 ==表名.ibd==文件中。

> show variables like 'innodb_file_per_table' 
> 参数设置的是是否将每个表的数据，索引单独存放在一个.ibd文件中。5.6.6之后默认开启

> 可以使用`ibd2sdi 表名.ibd`查看表的数据



##### 逻辑存储结构：

![InnoDB逻辑结构](https://ChengHaoRan666.github.io/picx-images-hosting/MySQL/InnoDB逻辑结构.3uv6p4jsos.webp)

**Tablespace（表空间）**

- 是 InnoDB 存储引擎管理数据的最顶层逻辑结构。
- 可以是共享系统表空间（如 `ibdata1`），也可以是每个表独立的表空间（`.ibd` 文件）。

**Segment（段）**

- 在表空间内，一个 **segment** 通常和一个具体的索引（如主键或二级索引）对应。
- 可以看作是存储逻辑上的单位，比如一个“数据段”或“索引段”。

**Extent（区）**

- Segment 向操作系统申请空间时，至少以 Extent 为单位分配。
- 每个 Extent 默认大小约为 1 MB（共包含 64 个 16 KB 的页），具体大小可由 `innodb_page_size` 设置决定。

**Page（页）**

- Page 是 InnoDB 的基本存储单位，默认大小为 16 KB，可配置为其他值。
- 每个页包含多个组成部分，包括：**FIL header/trailer（文件头尾）**、**页头（Page header）**、逻辑记录行（Row），以及页面目录（用于快速定位记录）等。

**Row（行）**

- 行记录存储在 Data Page（数据页）中。每条记录封装了多种信息：主键值（聚簇索引关键字）、事务 ID、回滚指针（undo log 定位）、非键列的实际数据等。
- Page 中还包含两个特殊的“哨兵”记录：**infimum**（值最小）和 **supremum**（值最大），用于标记记录的起始和结束位置，并且通过链表方式串接用户记录，支持顺序扫描。





#### 2. MyISAM

MyISAM是MySQL早期的默认存储引擎。



##### 特点：

1. 不支持事务，不支持外键
2. 支持表锁，不支持行锁
3. 访问速度快



##### 文件存储：

1. 表名.sdi：存储表结构信息
2. 表名.MYD：存储数据
3. 表名.MYI：存储索引





#### 3. MEMORY

Memory引擎的表数据是存储在内存中的，由于受到硬件问题，断电问题等影响，只能将这些表作为临时表或缓存使用。



##### 特点：

1. 内存存放
2. hash索引（默认）



##### 文件存储：

表名.sdi：存储表结构信息





#### 4. 总结

| 特点         | InnoDB              | MyISAM | Memory |
| ------------ | ------------------- | ------ | ------ |
| 存储限制     | 64TB                | 有     | 有     |
| 事务安全     | 支持                | -      | -      |
| 锁机制       | 行锁                | 表锁   | 表锁   |
| B+tree 索引  | 支持                | 支持   | 支持   |
| Hash 索引    | -                   | -      | 支持   |
| 全文索引     | 支持 (5.6 版本之后) | 支持   | -      |
| 空间使用     | 高                  | 低     | N/A    |
| 内存使用     | 高                  | 低     | 中等   |
| 批量插入速度 | 低                  | 高     | 高     |
| 支持外键     | 支持                | -      | -      |



### 4. 存储引擎选择

在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据 实际情况选择多种存储引擎进行组合。

- InnoDB: 是Mysql的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要 求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操 作，那么InnoDB存储引擎是比较合适的选择。 
- MyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。 
- MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是 对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。



## 索引

索引（index）是帮助MySQL高效获取数据的数据结构（有序）在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构 上实现高级查找算法，这种数据结构就是索引



优点：

1. 提高数据检索效率，降低数据库IO成本
2. 通过索引对数据进行排序，降低数据排序成本，降低CPU消耗

缺点：

1. 数据库也需要维护记录索引，会占用一定空间
2. 索引大大提高了查询的效率，同时也降低了更新表的速度，对表进行增删改操作时速度降低



### 1. 索引数据结构

MySQL的索引是在存储引擎层实现的，不同的存储引擎支持的索引不同。索引主要包括：

| 索引结构                            | 描述                                                         |
| ----------------------------------- | ------------------------------------------------------------ |
| <font color="red">B+Tree索引</font> | 最常见的索引类型，大部分引擎都支持 B+ 树索引                 |
| Hash索引                            | 底层数据结构是用哈希表实现的, 只有精确匹配索引列的查询才有效, 不 支持范围查询 |
| R-tree（空间索引）                  | 空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类 型，通常使用较少 |
| Full-text（全文索引）               | 是一种通过建立倒排索引,快速匹配文档的方式。类似于 Lucene,Solr,ES |

不同存储引擎对索引数据结构的支持：

| 索引           | InnoDB           | MyISAM | Memory |
| -------------- | ---------------- | ------ | ------ |
| B+tree 索引    | 支持             | 支持   | 支持   |
| Hash 索引      | 不支持           | 不支持 | 支持   |
| R-tree 索引    | 不支持           | 支持   | 不支持 |
| Full-text 索引 | 5.6 版本之后支持 | 支持   | 不支持 |

#### 1. 二叉树

如果使用二叉树，比较理想的情况是：

![二叉树](https://ChengHaoRan666.github.io/picx-images-hosting/MySQL/二叉树.8hgtpv7suh.webp)

但是会出现极端情况：

![极端二叉树](https://ChengHaoRan666.github.io/picx-images-hosting/MySQL/极端二叉树.8adlufo303.webp)

可见，使用二叉树存在两个问题：

1. 顺序插入时，会形成一个链表，查询效率大大降低
2. 数据过多时，深度过大，检索性能慢



#### 2. 红黑树

解决第一个问题可以改为使用红黑树，红黑树自旋会让树保持平衡，但是第二个问题红黑树还是没法解决

![红黑树](https://ChengHaoRan666.github.io/picx-images-hosting/MySQL/红黑树.54y3vhywig.webp)



> 所以在实现索引时，并没有采用二叉树或红黑树



#### 3. b 树

b树是一个多叉路衡查找树，相较于二叉树，b 树每个节点可以有多个分支，即多叉

一个最大度数（一个节点的子节点的数量）为5的 b 树，每个节点最多存储 4 个 key，5 个指针

![b树](https://ChengHaoRan666.github.io/picx-images-hosting/MySQL/b树.8hgtpvlj6h.webp)



#### 4. b+ 树

1. 所有数据都存在叶子节点
2. 非叶子节点只存放索引（key）和子指针
3. 叶子节点之间通常用链表相连

![b+树](https://ChengHaoRan666.github.io/picx-images-hosting/MySQL/b+树.4uba2d6nsr.webp)



Mysql对于b+树又做了优化：增加一个指向相邻叶子节点 的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序

![Mysql优化后b+树](https://ChengHaoRan666.github.io/picx-images-hosting/MySQL/Mysql优化后b+树.wiwlp0tnq.webp)



#### 5. Hash

哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在 hash表中。

如果两个(或多个)键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。



特点：

1. Hash索引只能用于对等比较(=，in)，不支持范围查询（between，>，< ，...）
2. 无法利用索引完成排序操作
3. 查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索引



### 2. 索引分类









### 3. 索引语法



### 4. SQL性能分析



### 5. 索引使用



### 6. 索引设计原则
